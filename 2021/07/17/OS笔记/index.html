

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Ricardo">
  <meta name="keywords" content="">
  
  <title>OS - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"ricardo-m-sakura.github.io.git","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Sakura</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/images/bp.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="OS">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-07-17 20:45" pubdate>
        July 17, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      105
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">OS</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：August 9, 2021 pm
                
              </p>
            
            <div class="markdown-body">
              <h3 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h3><p>并发部分一开始没有记笔记，后续会慢慢补上。sry、、</p>
<p>硬件和软件之间的桥梁：</p>
<p>​    硬件和软件之间有一个最小的约定,CPU reset之后。会到固件去执行。固件会把磁盘的第一个512字节，加载到内存的一个特定位置，这时候代码就已经获得了计算机的控制权。</p>
<p>​    操作系统进行内存分配的两个系统调用，brk和mmp。</p>
<p>​    堆区的末尾就是brk，sbrk通过改变指针来改变堆区的大小，来改变分配内存的大小。</p>
<p>​    mmap可以返回地址空间里的一段内存。</p>
<p>​    glibc中，一般大内存分配采用mmap直接分配，小内存分配通常采用brk&amp;sbrk。^_^ </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">古代方法<br> 	<span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">sbrk</span><span class="hljs-params">(<span class="hljs-type">intptr_t</span> increment)</span></span>;<br>现代方法<br>    <span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr,<span class="hljs-comment">//建议的分配位置，可为NULL</span></span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-type">size_t</span> length,<span class="hljs-comment">//大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-type">int</span> port,<span class="hljs-comment">//访问权限 PROT_READ / PROT_WRITE</span></span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-type">int</span> flags <span class="hljs-comment">//MAP_ANONYMOUS,匿名映射 = 内存分配</span></span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-type">int</span> fd,<span class="hljs-comment">//不涉及任何文件描述符；-1</span></span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-type">off_t</span> offset)</span></span>;<span class="hljs-comment">// 0</span><br>)<br></code></pre></td></tr></table></figure>

<h4 id="Conditional-Variables（条件变量，CV）"><a href="#Conditional-Variables（条件变量，CV）" class="headerlink" title="Conditional Variables（条件变量，CV）"></a>Conditional Variables（条件变量，CV）</h4><p>同步的本质：当某个条件满足时，线程执行，否则等待。</p>
<p>可以用一个对象来表示条件的满足/不满足！</p>
<p>条件不满足：随时可以在这个对象上<strong>等待</strong>。</p>
<p>条件满足：另一个线程发现条件满足，<strong>唤醒</strong>一个（所有）正在等待的线程。</p>
<h4 id="CV-API"><a href="#CV-API" class="headerlink" title="CV API"></a>CV API</h4><p><strong>wait</strong>:线程发现条件不满足，需要进入睡眠状态，等待CV上事件的发生。</p>
<p><strong>signal/notify</strong>:报告CV上事件的发生，如果有线程正在等待CV，则唤醒其中一个线程。</p>
<p><strong>broadca/notifyALL</strong>:因为有可能有多个事件在等待这个条件变量上事件的发生，报告CV上事件的发生，唤醒全部正在等待CV的线程。</p>
<h4 id="条件变量和互斥锁联合使用"><a href="#条件变量和互斥锁联合使用" class="headerlink" title="条件变量和互斥锁联合使用"></a>条件变量和互斥锁联合使用</h4><p>在条件变量wait之前，获得一把互斥锁，条件不满足的时候执行wait，释放锁。如果其他线程对执行wait的线程进行signal（唤醒）的话，那么这个线程会试图获取这把互斥锁，才能接着往下执行代码，最后释放锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">mute_lock</span>(&amp;mutex);<br>.....     <span class="hljs-comment">//其他代码</span><br><span class="hljs-built_in">wait</span>(&amp;CV,&amp;mutex);<br>.....     <span class="hljs-comment">//任意代码，包括循环</span><br><span class="hljs-built_in">mute_unlock</span>(&amp;mutex);<br><span class="hljs-comment">//signal不受互斥锁的约束</span><br></code></pre></td></tr></table></figure>

<h4 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore(信号量)"></a>Semaphore(信号量)</h4><p>互斥锁的概念：可以把互斥锁理解为游泳池的一个手环，由泳池管理员进行分配，游泳人员想要进入泳池必须从管理员那拿到这个手环。游完泳出来之后再把手环还给管理员。</p>
<p>也可以给管理员多个手环，比如前四个到来的都可以从管理员那得到手环进入泳池，第五个人就必须等待。信号量就是在这个基础上做了一个更有意思的改变。就是让进入泳池的人随时变出一个手环，可以看作是为token（令牌），得到token的就可以执行，得不到就得等待。这个手环就是信号量。</p>
<p>信号量有两个操作。P操作可以理解为：去admin那询问有没有手环，如果有就可以进入泳池。V操作可以理解为，任何一个同学不论是在泳池还是在其他地方，都可以把手环还给admin。</p>
<p>以上：就是信号量和PV操作。想要获得资源就要进行P操作，想要释放资源就要进行V操作。</p>
<p>同时，信号量 = 互斥锁和CV的结合体</p>
<p>~互斥锁：</p>
<p>​    仅有一个手环的情况下，P = lock ， V= unlock</p>
<p>~条件变量：</p>
<p>​    手环的数量作为等待的条件</p>
<p>P = wait  V =  signal</p>
<h3 id="Virtualization"><a href="#Virtualization" class="headerlink" title="Virtualization"></a>Virtualization</h3><p>应用只能通过系统调用和OS进行交互，除此之外应用就只能做它自己的程序代码所描述的事情。</p>
<p>所以在应用视角，OS就是一组系统调用API。而在硬件视角，就是一个状态机，一个C程序。</p>
<p>OS也是一个应用程序，那么OS是如何支撑这么多应用程序的运行呢？</p>
<p>它做的一件事其实是状态机的模拟。OS状态机的内存和寄存器和应用程序的内存和寄存器有一些不同，OS的状态机可以看到完整的物理内存，其次有一些应用程序无法访问的系统寄存器。OS所做的事情就是用OS的内存和寄存器去模拟应用程序的状态机。</p>
<p>OS所做的一件事情实际是就是所谓的虚拟化，虚拟化的就是为每一个程序提供一个虚拟的执行环境。</p>
<p>OS“模拟”了其中所有进程的状态机，这就是“虚拟化”，程序仿佛独占CPU运行，但其实独占的只是CPU的一部分（还有其他部分看不见）。通过把CPU分成用户执行进程的模式和操作系统执行进程的模式就实现了程序的虚拟化。CPU有两种运行的模式，即：用户态（User mode）和内核态(kernel mode)。应用程序始终在用户态上运行，OS始终在内核态上运行。操作系统希望执行哪个应用程序的时候，就会把自己切换到那个应用程序的状态机和用户态上执行。发生系统调用或者中断，就会从用户态切换到内核态。</p>
<p>OS也可以理解为一个中断处理程序，通过中断完成内核态和用户态的切换。</p>
<p>状态机的管理：创建状态机</p>
<p>fork：做的就是一份状态机完整的复制（内存，寄存器现场，堆栈等），fork创建出来的进程叫做子进程，执行fork的进程叫做父进程。fork（）返回创建出来的进程的PID，子进程返回0。</p>
<p>状态机的管理：替换状态机</p>
<p>execve:  某个状态机有一天会执行execve，在此之前，会把filename,argv,enpv，这三个参数准备好，执行execve这个系统调用，发生的事情就是，这个程序从filename开始执行，给filename这个程序传递main</p>
<p>函数，传递argv，和envp。也就是说execve好像执行的是状态机的reset,把某个程序复位为开始执行的状态。 </p>
<p>PATH环境变量：就是可执行文件的搜索路径。</p>
<p>状态机的管理：终止状态机</p>
<p>exit: 销毁一个状态机，并拥有一个返回值。但有一个问题是，状态机里可能有多个线程…</p>
<p>结束程序执行的三种方法：1：exit(0) - stdlib.h中声明的libc函数，会调用atexit</p>
<p>2：_exit(0) - glibic的syscall wrapper，执行 “exit_group”系统调用终止整个进程（所有线程），不会调用atexit，Linux中可以用strace查看。</p>
<p>3：syscall(SYS_exit,0)，执行”exit”系统调用终止当前线程，同时，也不会调用atexit。</p>
<p>主要，要区分好库函数（应用程序的一部分）和系统调用就好啦。</p>
<h4 id="操作系统中的进程"><a href="#操作系统中的进程" class="headerlink" title="操作系统中的进程"></a>操作系统中的进程</h4><p>​    如何实现一个操作系统？</p>
<h5 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">只分配不回收的...<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">kalloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">uintptr_t</span> brk = <span class="hljs-number">0</span>;<br>    brk = brk  ? <span class="hljs-comment">//如果是第一次调用，进入？的另一个分支， </span><br>        <span class="hljs-built_in">ROUNDUP</span>(brk,size) + size:<span class="hljs-comment">//不是第一次调用进入的分支，把brk置为下一个内存分配的起始点。 </span><br>    	(<span class="hljs-type">uintptr_t</span>)_heap.start + size; <span class="hljs-comment">//第一次调用进入的分支</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)(brk - size)<br> &#125;<br><span class="hljs-type">void</span> <span class="hljs-built_in">kfree</span>(<span class="hljs-type">void</span> *ptr) &#123; &#125;<br></code></pre></td></tr></table></figure>

<h5 id="内核多线程"><a href="#内核多线程" class="headerlink" title="内核多线程"></a>内核多线程</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> <span class="hljs-title class_">task</span>&#123;<br>    <span class="hljs-keyword">struct</span>&#123; <br>    _Context *conteext;<br>    _AddressSpace vm;<br>        <span class="hljs-type">char</span> *page,*cmd;<br>    &#125;;<span class="hljs-comment">//匿名结构体</span><br>    <span class="hljs-type">uint8_t</span> stack[<span class="hljs-number">8192</span>];<br>&#125;Task;<br>Task tasks[] = &#123; ... &#125;,**current;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> current currents[_cpu]</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">intptr_t</span> <span class="hljs-type">lock_t</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spin_lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lk)</span></span>&#123; _intr_write(<span class="hljs-number">0</span>); <span class="hljs-keyword">while</span> (_atomic_xchg(lk,<span class="hljs-number">1</span>)); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spin_unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lk)</span></span>&#123; _atomic_xchg(lk,<span class="hljs-number">0</span>)); _intr_write(<span class="hljs-number">1</span>); &#125;<br><span class="hljs-function">_Context *<span class="hljs-title">schedule</span><span class="hljs-params">(_Context *ctx)</span> </span>&#123; <br>	<span class="hljs-keyword">if</span>(!current) current = &amp;tasks[<span class="hljs-number">0</span>];     <span class="hljs-comment">//current代表系统中当前运行的线程。</span><br>    <span class="hljs-keyword">else</span> current-&gt;context = ctx;           <span class="hljs-comment">//记录寄存器现场，以及保存上下文。</span><br>    <span class="hljs-keyword">do</span> &#123; <br>        <span class="hljs-keyword">if</span>(++current = tasks + <span class="hljs-built_in">LENGTH</span>(tasks)) <br>            current = &amp;tasks[<span class="hljs-number">0</span>];<br>    &#125;<span class="hljs-keyword">while</span>((current - tasks) % _ncpu() != _cpu());<span class="hljs-comment">// 线程的编号 模 所有处理器的数量等于当前处理器编号的时候，才会将这个线程调度到这个处理器上执行。</span><br>    <span class="hljs-keyword">return</span> current-&gt;context;               <span class="hljs-comment">//把当前处理器现场恢复到处理器上 </span><br>&#125; <span class="hljs-comment">//在中断的驱动下，做上下文的切换，把CPU进行了虚拟化。</span><br></code></pre></td></tr></table></figure>

<h5 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">.............<br></code></pre></td></tr></table></figure>

<h5 id="进程和系统调用"><a href="#进程和系统调用" class="headerlink" title="进程和系统调用"></a>进程和系统调用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//每一个进程都有自己的虚拟空间，而这个虚拟空间是寄存器CR3l控制的 ，在中断处理程序的时候，在 T1进程iret之前，把T2进程的CR3放到CPU上就完成了进程的切换。 </span><br></code></pre></td></tr></table></figure>





<h4 id="进程抽象：Linux进程的地址空间"><a href="#进程抽象：Linux进程的地址空间" class="headerlink" title="进程抽象：Linux进程的地址空间"></a>进程抽象：Linux进程的地址空间</h4><hr>
<p>进程执行指令需要代码，数据，堆栈。。。</p>
<p>​    代码：（main,%rip 会从此处取出待执行的指令）</p>
<p>​    数据：（static int x）</p>
<p>​    堆栈：（int y）</p>
<p>他们都可以用<strong>指针</strong>访问</p>
<p>​    动态链接库</p>
<p>​    运行时分配的内存。 </p>
<hr>
<p>  进程的地址空间 = 内存里若干个连续的“ 段 ”</p>
<p>​    每一段是可访问（读/写/执行）的内存</p>
<p>​        可能映射到某个文件和/或在进程间共享</p>
<p>管理进程地址空间的系统调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr,<span class="hljs-type">size_t</span> length,<span class="hljs-type">int</span> prot,<span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd,<span class="hljs-type">off_t</span> offset)</span></span>;<span class="hljs-comment">//分配  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr,<span class="hljs-type">size_t</span> length)</span></span>;<span class="hljs-comment">//回收</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mprotect</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr,<span class="hljs-type">size_t</span> length,<span class="hljs-type">int</span> prot)</span>；<span class="hljs-comment">//修改内存的权限</span></span><br></code></pre></td></tr></table></figure>

<p>mmap也可以把文件映射到进程地址空间。 </p>
<p>进程状态中的内存其实是由一段一段内存映射的区域构成的，这个区域可以用mmap这样的系统调用来进行修改。</p>
<p>查看进程的地址空间：pmap </p>
<hr>
<p>Virtual system call : <strong>只读</strong>的系统调用也许可以不陷入内核执行。</p>
<h4 id="Virtual-system-call-：-实现"><a href="#Virtual-system-call-：-实现" class="headerlink" title="Virtual system call ： 实现"></a>Virtual system call ： 实现</h4><p>vvar：内核和进程共享的数据</p>
<p>vdso(virtual dynamic shared object)：系统调用代码实现（是操作系统的一部分）</p>
<p>vsyscall：是普通系统调用的包装</p>
<p>小tips：访问进程的地址空间，劫持进程的控制流，就是游戏外挂的本质！、</p>
<p>操作系统也是一个状态机，但是OS看见的内存是物理内存。</p>
<p>那么如何用一块物理内存模拟（Virtualize）一个进程的虚拟空间呢？</p>
<p>我们需要一个函数 f : [0,M) —&gt;  [0,M)</p>
<p>把“虚拟地址”翻译成“物理地址”，毕竟我们的内存只有一份，f由操作系统控制（应用程序不可见）：可以把f“装载”到CPU上，此后任何指令访问地址x（包括取指令），都访问实际的物理地址f(x)，任何越权访问将会触发异常。</p>
<p>​    那么问题又来了，如何高效的在硬件上实现f（） ？</p>
<p>​    f（）有一些要求：支持f（）在运行时的动态修改（mmap,munmap）；非常节约：f（）的存储开销必须远小于实际使用的内存；非常高效：因为每次访问都要计算f(x)。</p>
<p>​    <strong>分页机制</strong>：不必维护 [0,M) —&gt;  [0,M)的映射，而是把地址空间切成大小是P的“页面”。只维护[0,M / P ) —&gt;  [0,M / P)，的映射。需要一个内存中的数据结构来描述这样的映射，这种数据结构就是<strong>字典树</strong>。假设一个32bit的地址空间，我们要构造一个两层字典树，第一层为PD（Page Directory,页目录），第二层为PT(Page Table,页表)，其次就是一个真正的页面。将32位分成10-10-12。第一个10bit查找PD，第二个10bit查找PT，最后来找到其相应的页面。以上，本质上就是用一个字典树来维护虚拟地址到物理地址的翻译。</p>
<p>X86-64是一个四层的字典树(其实只用了48bit)从上到下依次是（PLM4  PDPT  PD  PT）。</p>
<p>mmap实现非常快，因为实际上它只维护了一张表，比如[7f1881238 - 1fcbaas2133]这段地址空间映射到一个文件。mmap就结束了，他没有给这个进程分配任何一个地址空间。只需要“让OS知道这么映射就够了”，进程访问页面会发生缺页，进入操作系统。缺页时，操作系统会得到缺页的地址。  结合之前说的，进程的地址空间是由一段一段构成的，操作系统没有必要在这一段创建的时候立刻分配内存，而是OS可以等到进程访问这个页面的时候，产生了page fault以和再分配，是一种lazy的分配。如果访问页面合法，分配一页：其中，匿名内存-》直接返回；文件-》执行read，把文件数据读到内存。如果访问非法，发送信号（SIGSEGV）,就是我们看见的segmentation fault。</p>
<h4 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h4><h5 id="Round-Robin"><a href="#Round-Robin" class="headerlink" title="Round-Robin"></a>Round-Robin</h5><p>​    假设当前Ti运行，中断后试图切换到下一个进T(i + 1) mod n  ，如果下一个进程正在等待I/O返回，继续执行下一个，如果系统所有的进程都不需要CPU，就调度idel进程（<del>专门用来等待的空循环,因为CPU每时每刻都必须执行指令。</del>）执行。</p>
<h5 id="引入优先级"><a href="#引入优先级" class="headerlink" title="引入优先级"></a>引入优先级</h5><p>Unix niceness, nice value (-20,-19,18……18,19),value值越小，越会占用CPU。value值相差10，CPU获得相差10倍..</p>
<p><del>好人流下了悔恨的泪水</del>。</p>
<h5 id="多级反馈调度（MLFQ）"><a href="#多级反馈调度（MLFQ）" class="headerlink" title="多级反馈调度（MLFQ）"></a>多级反馈调度（MLFQ）</h5><p>设置若干个Round-Robin队列，每个队列对应一个优先级，调度策略是优先调度高优先级队列  Q8 Q7 Q6 Q5 …. 可以在进程运行的时候对进程的实际行为进行观测，可以动态的调整进程的优先级。 </p>
<h5 id="Complete-Fair-Scheduling-CFS"><a href="#Complete-Fair-Scheduling-CFS" class="headerlink" title="Complete Fair Scheduling(CFS)"></a>Complete Fair Scheduling(<strong>CFS</strong>)</h5><p>Linux正在服役的调度策略。可以在中断发生时，观看每个进程过去的运行时间，理想情况下每个进程的运行时间应该是相同的，每次中断发生时，会补偿获得CPU上运行时间最少的进程。 会维护一个vruntime（virtual run time 虚拟运行时间），选择vruntime少的进程执行。</p>
<p>其中有一些复杂的情况，子进程会继承父进程的vruntime。</p>
<p>另外一种情况，假设有一个进程睡眠了很长时间，它的vruntime非常小，会不断占用CPU，那么其他的进程就会产生饥饿， Linux解决的办法就是让唤醒之后的进程获得系统中最小的vruntime。</p>
<p>vruntime的使用：因为记录的是虚拟运行时间，假设一个高优先级的进程实际运行了10S的物理时间，但是系统系统会记录1S的虚拟运行时间，高优先级的进程时间过得比较慢，这样可以得到更多的CPU来执行。低优先级的相反，进程的运行时间过的比较快。</p>
<p>vruntime的实现：<del>红黑树</del>。</p>
<h5 id="优先级反转问题"><a href="#优先级反转问题" class="headerlink" title="优先级反转问题"></a>优先级反转问题</h5><p>优先级最高（nice value最小，为-20） bad guy (-20)  该进程也想获得和very nice guy一样的互斥锁，但是因为该锁还没有释放，所以需要等待。</p>
<p>优先级其次（5）nice guy(5)：此时该进程就获得了比bad guy更高的优先级，此时就发生了反转。</p>
<p>优先级最低（19）very nice guy(19) 假设这个进程先执行，首先该进程得到了一把互斥锁，在还没有释放之前 中断来临。</p>
<p><strong>解决办法</strong>：优先级继承/优先级提升，就是说低优先级的任务和高优先级的任务共享了同一把互斥锁，当高优先级的任务想获得这把互斥锁的时候，那么持有这把互斥锁的任务，都立即继承这个最高的优先级。 </p>
<h4 id="实现mmap：借助分页机制"><a href="#实现mmap：借助分页机制" class="headerlink" title="实现mmap：借助分页机制"></a>实现mmap：借助分页机制</h4><p>mmap的神奇之处：几乎总在瞬间完成，比如用mmap申请8GiB的内存空间，或者用mmap映射整个磁盘。 </p>
<p>实际上为mmap做映射和分配物理内存这两件事情是可以分开的 。所以，可以事先把分配的内存标记起来，不能读不能写也不能执行。</p>
<p>等到实际内存访问发生的时候，访问就会发生一个错误，希望OS能够捕捉这样一个错误，也就是缺页（page fault），OS可以根据这个缺页的地址， 来找到是哪个页面缺页了。这个页面是不是真的属于这个进程，如果真的属于这个进程，再lazy的把这个页面分配给这个进程。 </p>
<p>硬件其实提供了一个机制叫做分页，那么分页是什么呢？</p>
<p>​    其实，系统里有一个寄存器叫做CR3(是CPU的一部分)，可以给CR3填一个数值， 这个数值可以指向物理内存中的一个页面，可以把物理内存中的页面解读成一个数据结构，也就是解读成一个函数f，这个函数f就可以把进程地址空间的任何一个页面映射到物理内存中的某个页面，有一些页面会映射为空。同时我们可以在系统中对CR3执行mov指令，把CR3指向物理内存中 另外一个页面，就可以把新指向的页面解读成另外一个函数f，那么又可以将另外一个虚拟地址空间映射到物理内存中。靠着修改CR3寄存器的值，这样就实现了在地址空间中切换。</p>
<p>​    CR3寄存器其实是不分你我的，不管是用户进程的代码还是操作系统的代码都共享同一个函数f,所以在实现操作系统时要做的，就是把操作系统的代码和进程的代码都映射到同一个地址空间里。   进程中有一部分段时高权限可以访问，低权限不能访问的区域。 如果用户程序的指针去访问的话会直接segmentation fault，但是操作系统在中断之后是有权限访问的，操作系统就会很聪明的把进程的高权限访问区域都映射到同一份的操作系统内核的代码和数据。</p>
<p>​    demand paging：进程一开始并不需要获得它所持有的页面，而是只要当需要的时候才把这个页面给这个进程。</p>
<h4 id="Swqpping"><a href="#Swqpping" class="headerlink" title="Swqpping"></a>Swqpping</h4><p>当系统的内存不够时，可以把某个进程暂停，并且可以把它的任意一个页面取出来，放到磁盘上。</p>
<h5 id="Swqpping：策略"><a href="#Swqpping：策略" class="headerlink" title="Swqpping：策略"></a>Swqpping：策略</h5><p>Everything is about <em>prediction</em></p>
<ul>
<li>最优策略（Belady’s Algorithm）</li>
</ul>
<p>​            swap out 未来最后使用的页面（<del>如果能预测未来的话</del>）</p>
<ul>
<li>实际上：我们只要能近似准确的预测未来 <ul>
<li> 内存不足时把未来大概率不用的页面swap out</li>
<li>提前把可能使用的页面换入（prefetch）</li>
<li>page fault 时 swap in (进程才能继续执行)</li>
</ul>
</li>
</ul>
<h5 id="一些不太好的策略"><a href="#一些不太好的策略" class="headerlink" title="一些不太好的策略"></a>一些不太好的策略</h5><p><strong>FIFO：First-in First-out</strong></p>
<ul>
<li>明显不太好–有一些“hot”的页面（code/data）显然不应该被swap out</li>
</ul>
<p> <strong>Random</strong></p>
<ul>
<li>明显不太好–不小心把重要的页面换出去了</li>
</ul>
<p><strong>LRU(最近最少用)</strong></p>
<ul>
<li>但不好实现 :joy:<ul>
<li>注意“LRU”需要知道我们怎么“use”内存的</li>
<li>“use”内存的方式是一条load/store指令</li>
</ul>
</li>
</ul>
<hr>
<h4 id="终端：操作系统里的一个对象"><a href="#终端：操作系统里的一个对象" class="headerlink" title="终端：操作系统里的一个对象"></a>终端：操作系统里的一个对象</h4><p>终端是一个I/O设备，是一个可以读写的对象。</p>
<ul>
<li>“Everything is a file”–终端也是一个文件</li>
</ul>
<h5 id="向终端输出：支持一系列的ANSI-Escape-Codes"><a href="#向终端输出：支持一系列的ANSI-Escape-Codes" class="headerlink" title="向终端输出：支持一系列的ANSI Escape Codes"></a>向终端输出：支持一系列的ANSI Escape Codes</h5><ul>
<li>Start with ESC(\033)[</li>
<li>光标移动；屏幕清除/滚动；设置前景/背景色/粗体….</li>
<li>例子：ls –color | less，可以看到很多ESC</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESC  <span class="hljs-string">&quot;\O33[&quot;</span></span><br><span class="hljs-meta">#difine move(x,y) put(ESC <span class="hljs-string">&quot;%D;%Dh&quot;</span>,y + 1,x + 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> setbg(c)  put(ESC <span class="hljs-string">&quot;48;5;%dm&quot;</span>,c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> setfg(c)  put(ESC <span class="hljs-string">&quot;38;5;%dm&quot;</span>,c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clear()   put(ESC <span class="hljs-string">&quot;2J&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> reset()	  put(ESC <span class="hljs-string">&quot;39m&quot;</span> ESC <span class="hljs-string">&quot;49m&quot;</span>)</span><br></code></pre></td></tr></table></figure>

<p>因此如果打印二进制文件，”偶然“的escape code可能改变终端的行为</p>
<ul>
<li>reset(1) //复位终端</li>
</ul>
<h5 id="从终端输入"><a href="#从终端输入" class="headerlink" title="从终端输入"></a>从终端输入</h5><p>终端默认是”cooked(canonical) mode“，即自带一个”行编辑器“。</p>
<ul>
<li>vim用户: set -o vi(bash); bindkey -v (zsh)</li>
<li>只有按下回车键，read系统调用才返回</li>
</ul>
<hr>
<p>另一个是”raw mode“，按键即返回。</p>
<ul>
<li>有了它，就能实现vim啦！</li>
<li>有了它，给read设置一个timeout，就能在没有按键的前提下更新屏幕啦！</li>
</ul>
<p>一系列终端”密码“ </p>
<h5 id="操作系统还需要一个人机接口（Interface）"><a href="#操作系统还需要一个人机接口（Interface）" class="headerlink" title="操作系统还需要一个人机接口（Interface）"></a>操作系统还需要一个人机接口（Interface）</h5><p>需要一个程序管理人机 的交互</p>
<ul>
<li>这个程序就是操作系统的外壳（shell）</li>
</ul>
<p>操作系统的的内核（kernel）我们是没有办法直接使用的，必须加一个外壳，就是shell。shell通过OS的API和OS进行交互，shell是真正和用户对接的接口。</p>
<p>可以接收用户指令，启动/ 管理应用程序。</p>
<h5 id="UNIX-Shell"><a href="#UNIX-Shell" class="headerlink" title="UNIX Shell"></a>UNIX Shell</h5><p>​    Shell也是一个编程语言，就是为了管理系统当中的进程，文件以及各种各样的对象而诞生的编程语言，Shell实际上也是一个编程语言的解释器，解释执行这些命令。</p>
<ul>
<li><strong>interactive shell</strong>：（没有参数）收到一行，执行一行。</li>
<li><strong>non-interactive shell</strong>：就是普通的语言解释器。</li>
</ul>
<p>Shell是“人机接口”的含义：<strong>interactive shell</strong> <strong>是把用户给I/O设备的指令翻译成系统调用的应用程序</strong></p>
<ul>
<li>是<strong>用户眼中的操作系统</strong>（I/O设备）和<strong>应用程序眼中的操作系统</strong>（系统调用）的桥梁<ul>
<li>完整流程：用户 ⇨ I/O设备 ⇨ shell/应用程序 ⇨ 系统调用</li>
</ul>
</li>
</ul>
<h5 id="什么是文件描述符"><a href="#什么是文件描述符" class="headerlink" title="什么是文件描述符"></a>什么是文件描述符</h5><p>​    Shell需要从终端读取输入，向终端输出。终端是什么？</p>
<ul>
<li>终端是操作系统里的一个对象。</li>
</ul>
<p>​    文件描述符是进程用来访问操作系统对象的“指针” 。进程想要访问操作系统中的对象是不能直接访问的，因为进程有自己的地址空间，进程只能读写自己地址空间中的内存，操作系统虽然也映射了，但是进程不能访问，访问就会发生segmentation fault。所以如果进程想要访问操作系统中的对象就必须通过系统调用来完成，在设计系统调用的时候就会想到设计一个参数，能够允许进程指定希望读/写操作系统中的哪一个对象，这样的机制就是用文件描述符实现的。</p>
<p>​    可以理解为文件描述符就是进程中另外一个地址空间， 这个地址空间里的每一个就是指向操作系统对象的一个指针。</p>
<hr>
<p>任何操作系统都需要这样的机制</p>
<ul>
<li>Windows : 句柄（<del>迷惑的翻译行为</del>）<ul>
<li>其实英文是很形象的（把手）</li>
</ul>
</li>
</ul>
<p>UNIX认为，一个进程应该不会持有太多的操作系统对象</p>
<ul>
<li>用一个小整数就OK了<ul>
<li>0，1，2分别是stdin，std out，stderr</li>
<li>open会返回最小的未使用的整数、</li>
</ul>
</li>
</ul>
<h5 id="信号（Signal）机制"><a href="#信号（Signal）机制" class="headerlink" title="信号（Signal）机制"></a>信号（Signal）机制</h5><p>可以异步的将某个程序打断，并且让程序知道某件事情发生了。</p>
<ul>
<li><p>管道（pipe）/ 共享内存（mmap）都是同步的进程间通信机制</p>
</li>
<li><p>我们的硬件提供了某个异步的机制，你想到了吗？</p>
<ul>
<li>中断！</li>
</ul>
</li>
<li><p>虚拟化：进程是“虚拟计算机”</p>
</li>
<li><p>计算机上有</p>
<ul>
<li>在事件到来的时候中断处理器</li>
<li>跳转到处理器预设的中断处理程序</li>
</ul>
</li>
<li><p> 进程上也可以有</p>
</li>
<li><p>在事件到来的时候signal进程</p>
</li>
<li><p>跳转到处理器预设的signal处理程序</p>
</li>
</ul>
<h5 id="Signal-系统调用：注册信号处理"><a href="#Signal-系统调用：注册信号处理" class="headerlink" title="Signal 系统调用：注册信号处理"></a>Signal 系统调用：注册信号处理</h5><p>为编号为signum的信号设置处理程序handler</p>
<ul>
<li>信号的类型：Linux中用man 7 signal查看</li>
</ul>
<h5 id="Killx系统调用：-发送信号"><a href="#Killx系统调用：-发送信号" class="headerlink" title="Killx系统调用： 发送信号"></a>Killx系统调用： 发送信号</h5><p>kill -SIGNAME pid</p>
<ul>
<li>可以对刚才的handler程序发送SIGINT，SIGQUIT…..</li>
</ul>
<h5 id="信号在操作系统上的实现"><a href="#信号在操作系统上的实现" class="headerlink" title="信号在操作系统上的实现"></a>信号在操作系统上的实现</h5><p>..说实话这段没怎么听懂，听了好几遍了，，大概意思可能是中断发生的时候，寄存器和内存的现场都被“封存”在物理内存中。</p>
<p><strong>接着操作系统“模拟”一次函数调用</strong></p>
<ul>
<li>保存寄存器现场</li>
<li>准备参数，调用注册的signal handler</li>
<li>恢复寄存器现场，return到程序原先的执行流</li>
</ul>
<h5 id="Job-control"><a href="#Job-control" class="headerlink" title="Job control"></a>Job control</h5><p>听不懂…..卒</p>
<h3 id="Persistence-持久化"><a href="#Persistence-持久化" class="headerlink" title="Persistence(持久化)"></a>Persistence(持久化)</h3><h4 id="持久化的第一课：-存储介质"><a href="#持久化的第一课：-存储介质" class="headerlink" title="持久化的第一课： 存储介质"></a>持久化的第一课： 存储介质</h4><p>为了使数据能够持久的存储，存储设备必须基于物理上容纳数据的介质。</p>
<ul>
<li>non-volatility</li>
</ul>
<p>存储设备</p>
<ul>
<li>逻辑上可以看成一个bit/byte array</li>
<li>1TB的磁盘 = 1TB个1-byte</li>
<li>通常支持按块（block）的方式读写</li>
</ul>
<hr>
<p>几个重要的维度：价格，扩展性，速度，可靠性</p>
<hr>
<h4 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h4><p>通过N极或者S极向上来表示一个bit的information（0或1），介质比较稳定，所以information很稳定。  </p>
<p>优点：</p>
<ul>
<li>成本低</li>
<li>容量大</li>
</ul>
<p>缺点：</p>
<ul>
<li>存在机械部件</li>
<li>速度较慢且只能顺序读写  ⇦有没有办法克服呢？</li>
<li>保存环境苛刻</li>
</ul>
<p>应用场景：冷数据的专用备份</p>
<hr>
<h4 id="磁鼓"><a href="#磁鼓" class="headerlink" title="磁鼓"></a>磁鼓</h4><p>“并行版”的磁带，把磁带绕城一个圈，放在轴上，这个轴可以让很多圈的磁带，每个磁带有着对应的读写头，轴转的越快，读写速度越快。</p>
<hr>
<h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>盘片 + 柱面 + 磁道 + 扇区 = 定位到512字节</p>
<p>优点：</p>
<ul>
<li>成本低</li>
<li>容量大</li>
</ul>
<p>缺点</p>
<ul>
<li>随机读写性能下降</li>
<li>存在机械部件，可靠性一般</li>
<li>读写头划伤盘片</li>
</ul>
<p>应用场景：计算机系统的主力数据存储</p>
<h5 id="软盘"><a href="#软盘" class="headerlink" title="软盘"></a>软盘</h5><p>…</p>
<hr>
<h4 id="光（坑）"><a href="#光（坑）" class="headerlink" title="光（坑）"></a>光（坑）</h4><ul>
<li><p>挖坑</p>
<ul>
<li><p>在完美反射光线的表面上挖出（几乎）不反射 光线的坑</p>
</li>
<li><p>激光扫过表面，就能读出坑的信息来（比如：不反射光代表1，反射光代表0）</p>
<p>其实不是坑，是phase　change晶体（挖坑能量太大）</p>
</li>
</ul>
</li>
</ul>
<p>挖坑：优点和缺点</p>
<ul>
<li>​    优点：成本极低，容易大量复制、</li>
<li>缺点：存在机械部件，顺序读取性能尚可，随机读取很慢，可靠性差，<del>挖坑容易填坑难</del>，适合只读的应用场景。</li>
</ul>
<p>应用场景：<del>数字产品发行</del>（被互联网挤压的几乎没有生存空间了）</p>
<h4 id="Flash-Memory"><a href="#Flash-Memory" class="headerlink" title="Flash Memory"></a>Flash Memory</h4><p>通过充电和放电实现</p>
<p>几乎全是优点：扩展性好，没有机械部件，还便宜。</p>
<p>但是！一个致命的缺点是放点做不到100%放干净。充放电数千数万次以后，就好像是“充电”状态了。</p>
<p>再但是！随着软件的进步，SSD逐步取代了HDD，原因就是硬件不够，软件来凑，每个SSD上都运行着管理软件的应用程序</p>
<p>会管理虚拟块到物理块的映射。</p>
<h4 id="I-O设备，总线，DMA"><a href="#I-O设备，总线，DMA" class="headerlink" title="I/O设备，总线，DMA"></a>I/O设备，总线，DMA</h4><h5 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h5><p>I/O是沟通计算机和物理世界的桥梁，没有I/O，计算机就只能计算（把内存里的值搬到寄存器，运算，写回）。</p>
<p>在CPU看来</p>
<ul>
<li>I/O设备是一个能与CPU交换数据的接口</li>
<li>实际上CPU和设备的控制器交互（CPU并不知道图形是如何打印到纸上，像素点是怎么绘制到屏幕上的）<br><img src="/images/io.png" srcset="/img/loading.gif" lazyload></li>
</ul>
<p>CPU如何访问IO设备</p>
<ul>
<li>使用in/out指令，访问IO设备的寄存器</li>
<li>直接执行memory dereference 访问memory-mapped IO设备</li>
</ul>
<p>但是处理器只有很少的接口，怎么访问那么多的IO呢？那就是通过总线，将其他的IO先接到总线上。</p>
<h5 id="总线：一个特殊的I-O设备"><a href="#总线：一个特殊的I-O设备" class="headerlink" title="总线：一个特殊的I/O设备"></a>总线：一个特殊的I/O设备</h5><p>提供“另一个地址空间”和地址空间上的设备访问</p>
<ul>
<li>把收到的地址（总线地址）和数据进行转发</li>
</ul>
<h5 id="Direct-Memory-Access-DMA"><a href="#Direct-Memory-Access-DMA" class="headerlink" title="Direct Memory Access(DMA)"></a>Direct Memory Access(DMA)</h5><p>在系统里增加一个新的CPU，专门执行“memcpy”程序</p>
<ul>
<li>实际实现：直接把DMA控制器连接在总线和内存中<br><img src="/images/%7DMN9H%5B94A3SLPW3XGRCF4LR.png" srcset="/img/loading.gif" lazyload></li>
<li>DMA:内存的一致性：硬件维护一致性。</li>
</ul>
<h5 id="GPU：既是IO设备，也是处理器"><a href="#GPU：既是IO设备，也是处理器" class="headerlink" title="GPU：既是IO设备，也是处理器"></a>GPU：既是IO设备，也是处理器</h5><p>GPU的功能实际是执行多处理器并行程序（例如OPENGL CUDA）</p>
<ul>
<li>将执行结果写入内存（和/或视频输出）</li>
<li>nvcc：把main编译/链接成ELF；hello编译成GPU指令</li>
</ul>
<p>GPU和游戏有什么关系：</p>
<p>游戏不就是画点么…</p>
<ul>
<li>但CPU画不过来啊<ul>
<li> 几百万个三角形描述形状，tessellation，各种shaders</li>
<li>我们需要超高性能的并行处理器（GPU）</li>
</ul>
</li>
</ul>
<p>GPU的内部构造</p>
<p>非常复杂的异构多处理器系统,是异构的各种各样的，能效比非常高的，执行相对的不是那么通用的指令，并行度非常高，每秒钟执行指令的数量比CPU要高。</p>
<h4 id="设备的驱动程序"><a href="#设备的驱动程序" class="headerlink" title="设备的驱动程序"></a>设备的驱动程序</h4><h5 id="操作系统应该对I-O设备做什么？"><a href="#操作系统应该对I-O设备做什么？" class="headerlink" title="操作系统应该对I/O设备做什么？"></a>操作系统应该对I/O设备做什么？</h5><p>应用程序有访问I/O设备的需求</p>
<p>操作系统需要对设备进行<strong>抽象</strong>（虚拟化） </p>
<hr>
<p>I/O设备的抽象：对设备（文件描述符）的I（read）和O（write）</p>
<hr>
<p>I/O设备虽然复杂，但几乎都可以理解为字节的序列（流或数组）</p>
<ul>
<li>（read）从设备某个指定位置读入数据</li>
<li>（write）向设备某个指定位置写入数据</li>
<li>（ioctl）读取/设置设备的状态</li>
</ul>
<h4 id="操作系统：提供一个硬件抽象层"><a href="#操作系统：提供一个硬件抽象层" class="headerlink" title="操作系统：提供一个硬件抽象层"></a>操作系统：提供一个硬件抽象层</h4><p>操作系统的本质：管理硬件资源，为程序的执行提供服务。</p>
<p>在OS中建立一个新的抽象层</p>
<ul>
<li>以同一个接口访问不同的I/O设备</li>
<li>实现接口的代码就是设备驱动程序<ul>
<li> 把对设备的HAL（硬件抽象层）调用翻译成指令</li>
</ul>
</li>
</ul>
<hr>
<p>例子：应用使用系统调用访问文件描述符</p>
<ul>
<li>文件系统API ⇨ （操作系统代码翻译成）⇨HAL API⇨（设备驱动翻译成）⇨设备指令 &amp; 响应中断</li>
</ul>
<h5 id="设备驱动：硬件抽象层的实现"><a href="#设备驱动：硬件抽象层的实现" class="headerlink" title="设备驱动：硬件抽象层的实现"></a>设备驱动：硬件抽象层的实现</h5><p>设备驱动程序：对设备进行一定的管理，对上层提供统一的接口。将设备抽象为一个对象和操作</p>
<ul>
<li>以面向对象的方式访问I/O<ul>
<li>设备：支持read，write，ioctl…功能的对象</li>
</ul>
</li>
</ul>
<p>设备驱动程序把HAL API调用（read，write，ioctl）翻译成指令</p>
<hr>
<p>道理简单，写代码就麻烦了</p>
<ul>
<li>I/O设备看起来就是个“黑盒子”</li>
<li>写错任何代码就是simply “not work”</li>
</ul>
<h5 id="Linux设备驱动"><a href="#Linux设备驱动" class="headerlink" title="Linux设备驱动"></a>Linux设备驱动</h5><p>Everything is file (设备也是)</p>
<ul>
<li>所以设备提供文件操作就好了！</li>
</ul>
<h5 id="两类特殊的设备："><a href="#两类特殊的设备：" class="headerlink" title="两类特殊的设备："></a>两类特殊的设备：</h5><h5 id="磁盘-1"><a href="#磁盘-1" class="headerlink" title="磁盘"></a>磁盘</h5><p>磁盘（存储设备）的访问特性</p>
<ul>
<li><p>以数据块（block）为单位访问</p>
<ul>
<li> 传输有“最小单元”，不支持随机访问</li>
</ul>
</li>
<li><p>大吞吐量</p>
<ul>
<li>使用DMA传输数据</li>
</ul>
</li>
<li><p>应用程序一般不直接访问</p>
<ul>
<li>访问者通常是文件系统（维护磁盘上的数据结构）</li>
<li>大量的并发访问（操作系统中的进程都需要访问文件系统）</li>
</ul>
</li>
</ul>
<h5 id="Linux-Block-I-O-Layer"><a href="#Linux-Block-I-O-Layer" class="headerlink" title="Linux Block I/O Layer"></a>Linux Block I/O Layer</h5><p>文件系统和磁盘设备之间的接口</p>
<ul>
<li>I/O调度器<ul>
<li>曾经是“电梯”调度增加性能</li>
<li>现在是CFQ保证公平性</li>
</ul>
</li>
</ul>
<h5 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h5><p>网络的访问特性</p>
<ul>
<li>速度非常快</li>
<li>大小不确定</li>
<li>延迟敏感</li>
</ul>
<h5 id="Linux-net子系统"><a href="#Linux-net子系统" class="headerlink" title="Linux net子系统"></a>Linux net子系统</h5><p>Linux Kernel用独立的子系统（设备抽象和API）管理网络设备</p>
<h4 id="应用程序眼中的I-O设备"><a href="#应用程序眼中的I-O设备" class="headerlink" title="应用程序眼中的I/O设备"></a>应用程序眼中的I/O设备</h4><h5 id="设备-文件-（后面看不懂了）"><a href="#设备-文件-（后面看不懂了）" class="headerlink" title="设备 = 文件 （后面看不懂了）"></a>设备 = 文件 （<del>后面看不懂了</del>）</h5><h4 id="文件系统：存储设备的虚拟化"><a href="#文件系统：存储设备的虚拟化" class="headerlink" title="文件系统：存储设备的虚拟化"></a>文件系统：存储设备的虚拟化</h4><p>文件系统是<strong>保存在持久存储上的数据结构</strong></p>
<ul>
<li>规定了数据在磁盘上的存储方式</li>
<li>允许对数据结构进行的操作<ul>
<li>文件/目录系统调用</li>
</ul>
</li>
</ul>
<p>磁盘（I/O设备）=  一个可以读/写的字节序列</p>
<p>虚拟磁盘（文件） = 一个可以读/写的动态字节序列</p>
<p><strong>文件系统的实现 = 数据结构的查询/修改操作</strong></p>
<h5 id="层次结构的文件系统"><a href="#层次结构的文件系统" class="headerlink" title="层次结构的文件系统"></a>层次结构的文件系统</h5><ul>
<li>系统中可能有数百万的文件</li>
<li>key-value的方式不便于人类用户使用</li>
</ul>
<p>目录：文件/目录的集合（形成一棵树）</p>
<ul>
<li>目录体现了<strong>局部性</strong>：相关的数据存放在相近的目录。</li>
</ul>
<h5 id="文件API：修改文件的数据"><a href="#文件API：修改文件的数据" class="headerlink" title="文件API：修改文件的数据"></a>文件API：修改文件的数据</h5><p>​    文件描述符：进程用来访问操作系统对象的“指针”</p>
<p>​    <strong>mmap</strong>:使用open打开一个文件以后</p>
<ul>
<li>用MAO_SHARED将文件映射到地址空间中</li>
<li>用MAP_PRIVATE创建一个copy-on-write的副本</li>
</ul>
<p>通过mmap，可以把进程虚拟空间中的一部分和虚拟磁盘建立关系，对磁盘上的数据访问就变成了对内存的访问。</p>
<p>映射的长度超过文件大小会发生什么？发生bus error</p>
<ul>
<li>ftruncate可以改变文件大小</li>
</ul>
<h5 id="文件访问的游标（偏移量）"><a href="#文件访问的游标（偏移量）" class="headerlink" title="文件访问的游标（偏移量）"></a>文件访问的游标（偏移量）</h5><p>文件的读写自带“游标”，这样就不用每次都指定写到哪里了</p>
<p>可以用<strong>lseek</strong>和<strong>ftell</strong>系统调用来改变/获取游标的位置</p>
<p>偏移量管理：</p>
<p>文件描述符在fork时会被子进程继承</p>
<h5 id="目录-文件系统API"><a href="#目录-文件系统API" class="headerlink" title="目录/文件系统API"></a>目录/文件系统API</h5><p>目录管理：创建/删除：</p>
<ul>
<li><p>mkdir</p>
<ul>
<li>可以创建一个目录</li>
<li>可以设置访问权限</li>
</ul>
</li>
<li><p>rmdir</p>
<ul>
<li>删除一个空目录</li>
<li>没有“递归删除”的系统调用</li>
<li>（应用层能实现的，就不要在OS层实现）</li>
<li>rm -rf会遍历目录，逐个删除</li>
</ul>
</li>
</ul>
<h5 id="硬（hard）链接"><a href="#硬（hard）链接" class="headerlink" title="硬（hard）链接"></a>硬（hard）链接</h5><p>​    允许一个文件被多个目录引用</p>
<ul>
<li>目录中仅存指向文件数据的指针</li>
<li>不能链接目录</li>
<li>不能跨文件系统</li>
</ul>
<p>​    小知识：其实所有的文件都是硬链接（删除文件使用unlink系统调用）</p>
<ul>
<li>引用计数减一，减到0时数据被回收</li>
</ul>
<h5 id="软（symbolic）链接"><a href="#软（symbolic）链接" class="headerlink" title="软（symbolic）链接"></a>软（symbolic）链接</h5><p>软链接：在文件里存储一个“跳转提示”</p>
<ul>
<li><p>软链接也是一个文件</p>
<ul>
<li>当引用这个文件时，去找另一个文件</li>
<li>另一个文件的绝对/相对路径以文本的形式存储在文件中</li>
<li>可以跨文件系统，可以链接目录</li>
</ul>
</li>
<li><p>允许多层链接</p>
<ul>
<li>a⇨b⇨c</li>
</ul>
</li>
<li><p>可以创建软链接的硬链接</p>
<ul>
<li>因为软链接也是文件</li>
</ul>
</li>
<li><p>OS在处理软链接时会执行路径解析</p>
</li>
</ul>
<h4 id="FAT文件系统"><a href="#FAT文件系统" class="headerlink" title="FAT文件系统"></a>FAT文件系统</h4><p>需求</p>
<ul>
<li>树状的目录结构</li>
<li>系统中以小文件为主</li>
<li>无需支持链接操作</li>
</ul>
<p>实现方式</p>
<ul>
<li>链表<ul>
<li>任何复杂的高级数据结构都显得浪费</li>
</ul>
</li>
</ul>
<h5 id="用链表存储数据：两种设计"><a href="#用链表存储数据：两种设计" class="headerlink" title="用链表存储数据：两种设计"></a>用链表存储数据：两种设计</h5><ul>
<li><p>在每个数据块后放置指针</p>
<ul>
<li>优点：实现简单，无需单独开辟空间</li>
<li>缺点：数据的大小不是2^k,单独的lseek需要读整块数据</li>
</ul>
</li>
<li><p>将指针集中存放在文件系统的某个区域</p>
<ul>
<li>优点：局部性好，lseek更快</li>
<li>缺点：集中存放的数据损坏将导致数据丢失（解决办法:先备份一份）</li>
</ul>
</li>
</ul>
<h5 id="File-Allocation-Table"><a href="#File-Allocation-Table" class="headerlink" title="File Allocation Table"></a>File Allocation Table</h5><ul>
<li><p>把磁盘分成“cluster”</p>
<ul>
<li>文件系统头部BPB(BIOS Parameter Block)标记了cluster的大小</li>
</ul>
</li>
<li><p>在一段区域里（FAT）连续存放指针</p>
</li>
</ul>
<h4 id="目录树实现：目录文件"><a href="#目录树实现：目录文件" class="headerlink" title="目录树实现：目录文件"></a>目录树实现：目录文件</h4><p>目录 = 文件/目录的集合</p>
<ul>
<li>它本身也是一个数据结构</li>
<li>文件名到文件信息的映射</li>
</ul>
<h4 id="FAT-性能与可靠性"><a href="#FAT-性能与可靠性" class="headerlink" title="FAT:性能与可靠性"></a>FAT:性能与可靠性</h4><p>性能</p>
<ul>
<li>小文件简直太适合了</li>
<li>大文件的随机访问就不行了</li>
</ul>
<p>可靠性</p>
<ul>
<li>维护若干个FAT的副本防止元数据损坏</li>
<li>损坏的cluster在FAT中标记</li>
</ul>
<h4 id="EXT2-UNIX-文件系统"><a href="#EXT2-UNIX-文件系统" class="headerlink" title="EXT2/UNIX 文件系统"></a>EXT2/UNIX 文件系统</h4><ol>
<li>集中存储文件的元数据</li>
<li>大小文件可以用不同的方式处理</li>
</ol>
<h5 id="ext2目录文件"><a href="#ext2目录文件" class="headerlink" title="ext2目录文件"></a>ext2目录文件</h5><p>与FAT本质相同：在文件上建目录的数据结构</p>
<h5 id="性能与可靠性"><a href="#性能与可靠性" class="headerlink" title="性能与可靠性"></a>性能与可靠性</h5><p>大文件的随机读写性能明显提升</p>
<ul>
<li>支持链接</li>
<li>inode在磁盘上连续存储，便于缓存/预取</li>
<li>依然有碎片问题</li>
</ul>
<p>但可靠性依然是一个很大的问题</p>
<h4 id="持久数据的可靠性"><a href="#持久数据的可靠性" class="headerlink" title="持久数据的可靠性"></a>持久数据的可靠性</h4><h5 id="两种简单的Fault-Model"><a href="#两种简单的Fault-Model" class="headerlink" title="两种简单的Fault Model"></a>两种简单的Fault Model</h5><ul>
<li><p>random data corruption</p>
<ul>
<li>数据损坏</li>
</ul>
</li>
<li><p>fail-stop</p>
<ul>
<li>磁盘好像就“忽然消失了“</li>
</ul>
</li>
</ul>
<p>以上两种情况都假设能立即检测出问题</p>
<h5 id="Random-data-corruption"><a href="#Random-data-corruption" class="headerlink" title="Random data corruption"></a>Random data corruption</h5><h5 id="FAT文件系统中一个cluster损坏的几种情况"><a href="#FAT文件系统中一个cluster损坏的几种情况" class="headerlink" title="FAT文件系统中一个cluster损坏的几种情况"></a>FAT文件系统中一个cluster损坏的几种情况</h5><ul>
<li><p>元数据损坏(FAT) ←高破坏性</p>
<ul>
<li>碎片的文件（以当时的技术）彻底无法恢复</li>
<li>顺序存储的文件</li>
</ul>
</li>
<li><p>系统文件损坏</p>
<ul>
<li>可能无法进入系统</li>
<li>但重新安装系统即可无缝修复</li>
</ul>
</li>
<li><p>数据文件丢失</p>
<ul>
<li>丢失一个文件</li>
<li>勉强可以接受（重要的文件手工备份）</li>
</ul>
</li>
</ul>
<h5 id="应对部分数据损坏"><a href="#应对部分数据损坏" class="headerlink" title="应对部分数据损坏"></a>应对部分数据损坏</h5><p>自动备份最重要的数据（FAT）* K</p>
<ul>
<li>K由文件系统初始化（格式化；mkfs）时设置</li>
</ul>
<h5 id="FAT-K-性能分析"><a href="#FAT-K-性能分析" class="headerlink" title="FAT * K 性能分析"></a>FAT * K 性能分析</h5><p>典型操作</p>
<ul>
<li><p>FAT读取</p>
<ul>
<li>从FAT-1照常读取</li>
</ul>
</li>
<li><p>FAT-i 损坏（磁盘I/O会返回失败）</p>
<ul>
<li>从FAT-( i + 1)读取</li>
</ul>
</li>
<li><p>FAT更新</p>
<ul>
<li>需要同时写入FAT-1,FAT-2…..FAT-K<ul>
<li>FAT更新的速度降低为1/K;</li>
<li>等等–FAT时在内存中缓存的（写入频率非常低，使用的是wirie back法）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Fail-Stop"><a href="#Fail-Stop" class="headerlink" title="Fail Stop"></a>Fail Stop</h5><p>RAID (Redundant Array of Inexpensive Disks)</p>
<ul>
<li>把多个（不可靠的）磁盘虚拟成一块非常可靠的虚拟磁盘</li>
</ul>
<h5 id="怎样用不可靠的磁盘构造更可靠的磁盘"><a href="#怎样用不可靠的磁盘构造更可靠的磁盘" class="headerlink" title="怎样用不可靠的磁盘构造更可靠的磁盘"></a>怎样用不可靠的磁盘构造更可靠的磁盘</h5><ul>
<li><p>通过设备驱动程序抽象成“一个硬盘”V</p>
<ul>
<li>实际上：两块磁盘A,B上的数据构成“镜像”</li>
</ul>
</li>
<li><p>read(V,blk)</p>
<ul>
<li>可以从A或B中的任意一个读取</li>
</ul>
</li>
<li><p>write(V,blk)</p>
<ul>
<li>将同样的数据写入A，B的同一位置</li>
</ul>
</li>
</ul>
<h4 id="崩溃一致性"><a href="#崩溃一致性" class="headerlink" title="崩溃一致性"></a>崩溃一致性</h4><h5 id="导致崩溃一致性的原因"><a href="#导致崩溃一致性的原因" class="headerlink" title="导致崩溃一致性的原因"></a>导致崩溃一致性的原因</h5><p>数据结构的维护需要多个数据块的写入  </p>
<p>考虑文件追加写的三个writes</p>
<ul>
<li>【1】文件的inode（size，索引） 【2】data bitmap 【3】data block </li>
</ul>
<h5 id="崩溃恢复：FSCK-（-File-System-Checking）"><a href="#崩溃恢复：FSCK-（-File-System-Checking）" class="headerlink" title="崩溃恢复：FSCK （ File System Checking）"></a>崩溃恢复：FSCK （ File System Checking）</h5><p>FSCK:根据磁盘上已有的信息，恢复出最可能的数据结构</p>
<p>恢复规则：例子</p>
<ul>
<li>检查inode标记的数据块是否bitmap都标记为“1”</li>
<li>检查inode数据是否”看起来合法“，否则删除</li>
<li>检查是否存在dangling link<ul>
<li>没有链接的inode被移到 lost+found 目录中</li>
</ul>
</li>
</ul>
<p>如果fsck的时候发生崩溃，文件系统可能进入彻底无法恢复的状态</p>
<h5 id="Journaling（日志）"><a href="#Journaling（日志）" class="headerlink" title="Journaling（日志）"></a>Journaling（日志）</h5><p>flush机制：只有在flush之前的请求落盘之后，才会开始flush之后的请求<br><img src="/images/jour.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><ul>
<li><p>Android系统上的应用程序</p>
<ul>
<li>开发门槛低（Java/Kotlin）<ul>
<li>对比死掉的Symbian：要么是C++，要么是阉割的 JAVA</li>
</ul>
</li>
<li>代码编译成Dalvik bytecode,APP打包成“apk”(zip archive)<ul>
<li>aptool 可以实现“解包”</li>
</ul>
</li>
</ul>
</li>
<li><p>运行在“Android Runtime” (ART)</p>
<ul>
<li> managed runtime</li>
<li>丰富的系统服务，运行库</li>
</ul>
</li>
</ul>
<p>Android Apps</p>
<p>每个app都是一个Linux进程</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/01/SCUACM/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">SCU_ACM预备队暑期训练</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/13/link-load-lib/">
                        <span class="hidden-mobile">链接，装载和库</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
